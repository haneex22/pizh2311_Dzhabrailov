# Лабораторная работа на неделю 1
## **Тема**: Объектно-ориентированное программирование на Python 
### Студента группы ПИЖ-б-о-23-1(1) Джабраилова Бекхана Магомедовича <br><br>
**Репозиторий Git:** https://github.com/haneex22/pizh2311_Dzhabrailov  

**Практическая работа урока 2:**  
*Задание:*  
Напишите программу по следующему описанию. Есть класс "Воин". От него создаются два экземпляра-юнита. Каждому устанавливается здоровье в 100 очков. В случайном порядке они бьют друг друга. Тот, кто бьет, здоровья не теряет. У того, кого бьют, оно уменьшается на 20 очков от одного удара. После каждого удара надо выводить сообщение, какой юнит атаковал, и сколько у противника осталось здоровья. Как только у кого-то заканчивается ресурс здоровья, программа завершается сообщением о том, кто одержал победу.  

**Практическая работа урока 3:**  
*Задание:*  
Напишите программу по следующему описанию:  
1. Есть класс Person, конструктор которого принимает три параметра (не учитывая self) - имя, фамилию и квалификацию специалиста. Квалификация имеет значение заданное по-умолчанию, равное единице.
2. У класса Person есть метод, который возвращает строку, включающую в себя всю информацию о сотруднике.
3. Класс Person содержит деструктор, который выводит на экран фразу "До свидания, мистер ... " (вместо троеточия должны выводиться имя и фамилия объекта).
4. В основной ветке программы создайте три объекта класса Person. Посмотрите информацию о сотрудниках и увольте самое слабое звено.
5. В конце программы добавьте функцию input(), чтобы скрипт не завершился сам, пока не будет нажат Enter. Иначе вы сразу увидите как удаляются все объекты при завершении работы программы.  

**Практическая работа урока 4:**  
*Задание:*  
Разработайте программу по следующему описанию.  
В некой игре-стратегии есть солдаты и герои. У всех есть свойство, содержащее уникальный номер объекта, и свойство, в котором хранится принадлежность команде. У солдат есть метод "иду за героем", который в качестве аргумента принимает объект типа "герой". У героев есть метод увеличения собственного уровня.  
В основной ветке программы создается по одному герою для каждой команды. В цикле генерируются объекты-солдаты. Их принадлежность команде определяется случайно. Солдаты разных команд добавляются в разные списки.  
Измеряется длина списков солдат противоборствующих команд и выводится на экран. У героя, принадлежащего команде с более длинным списком, поднимается уровень.  
Отправьте одного из солдат первого героя следовать за ним. Выведите на экран идентификационные номера этих двух юнитов.  

**Практическая работа урока 5:**  
*Задание:*
В качестве практической работы попробуйте самостоятельно перегрузить оператор сложения. Для его перегрузки используется метод __add__(). Он вызывается, когда объекты класса, имеющего данный метод, фигурируют в операции сложения, причем с левой стороны. Это значит, что в выражении а + b у объекта а должен быть метод __add__(). Объект b может быть чем угодно, но чаще всего он бывает объектом того же класса. Объект b будет автоматически передаваться в метод __add__() в качестве второго аргумента (первый - self).  
Отметим, в Python также есть правосторонний метод перегрузки сложения - __radd__().  
Согласно полиморфизму ООП, возвращать метод __add__() может что угодно. Может вообще ничего не возвращать, а "молча" вносить изменения в какие-то уже существующие объекты. Допустим, в вашей программе метод перегрузки сложения будет возвращать новый объект того же класса.  

**Практическая работа урока 6:**  
*Задание:*  
Разработайте класс с "полной инкапсуляцией", доступ к атрибутам которого и изменение данных реализуются через вызовы методов. В объектно-ориентированном программировании принято имена методов для извлечения данных начинать со слова get (взять), а имена методов, в которых свойствам присваиваются значения, - со слова set (установить). Например, getField, setField.  

**Практическая работа урока 7:**  
*Задание:*  
Исправьте код так, чтобы у объектов Room были только четыре поля - width, lenght, height и wd. Площади (полная и оклеиваемая) должны вычислять лишь при необходимости путем вызова методов.  
Программа вычисляет площадь под оклейку, но ничего не говорит о том, сколько потребуется рулонов обоев. Добавьте метод, который принимает в качестве аргументов длину и ширину одного рулона, а возвращает количество необходимых, исходя из оклеиваемой площади.  
Разработайте интерфейс программы. Пусть она запрашивает у пользователя данные и выдает ему площадь оклеиваемой поверхности и количество необходимых рулонов.  

**Практическая работа урока 8:**  
*Задание:*  
Напишите класс Snow по следующему описанию.  
В конструкторе класса инициируется поле, содержащее количество снежинок, выраженное целым числом.  
Класс включает методы перегрузки арифметических операторов: _add_() -сложение, _sub_() - вычитание, _mul_() - умножение, _truediv_() - деление. В классе код этих методов должен выполнять увеличение или уменьшение количества снежинок на число n или в n раз. Метод _truediv_() перегружает обычное (), а не целочисленное (//) деление. Однако пусть в методе происходит округление значения до целого числа.  
Класс включает метод makeSnow(), который принимает сам объект и число снежинок в ряду, а возвращает строку вида " ***** \n ***** \n *****... ", где количество снежинок между "\n' равно переданному аргументу, а количество рядов вычисляется, исходя из общего количества снежинок.  
Вызов объекта класса Snow в нотации функции с одним аргументом, должен приводить к перезаписи значения поля, в котором хранится количество снежинок, на переданное в качестве аргумента значение.  

**Практическая работа урока 9:**  
*Задание:*  
В практической работе урока 7 "Композиция" требовалось разработать интерфейс взаимодействия с пользователем. Разнесите сам класс и интерфейс по разным файлам. Какой из них выполняет роль модуля, а какой - скрипта? Оба файла можно поместить в один каталог.   

**Практическая работа урока 10:**  
*Задание:*  
Выполните полное документирование модуля, созданного в практической работе прошлого урока.  

**Практическая работа урока 11:**  
*Задание:*  
Может ли в этой программе ученик учиться без учителя? Если да, пусть научится чему-нибудь сам.  
Добавьте в класс Pupil метод, позволяющий ученику случайно "забывать" какую-нибудь часть своих знаний.  
